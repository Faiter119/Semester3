9TekstsÃ¸k, Datakompresjon

Helge Hafting

IIE

Seksjon 1 Ç	




  â€¢ Frit¶$ i dokumenter, nettsider og lignende§   â€¢ FritekstsÃ¸k i databaser

àSÃ¸kemotorer

Ïğ etter repeterte strenger forÁkompresjon


DNA-matchiÜ6







  Tekst: rabarbra     (lengde n)

  SÃ¸keord: àmíkyv së"et langs teksten, se om det passer/   â€¢ tegn som passer, vises med fet skrift

 ÑfÃ¸rste feilß	kursiv

 ¶&dobbeltlÃ¸kke for n-m posisjoner, og m“Degn i sÃ¸keordet. 

  


  Hele greia, O\left(n\cdot m\right),\OmegaäñÊ  ForsÃ¸k  | r  | a  | bö	óbš | r  | a  
-----û+éçåãáßİ----
    0     | b É|ôóñï   

  
  ForsÃ¸k  | r  | a  | bö	óbë
-----û+ÜÚØÖÔÒĞ----
    1     |û bº¸  |  ûù  

  
  ForsÃ¸k  | r  | a  | bö	óbë
-----û+ÂÀ¾¼º¸¶----¾	  2     |ûù b  | r  | a  |áß   

  
  ForsÃ¸kËÚÇÛÔ
-----û+¶´ó---+-ûù÷õ---
    3     |ûù÷ b  | r  | a  |Ë   

  
  ForsÃ¸k·Ü³İÖr  | a  
-----û+ìêèæäâà----
    4     |ûù÷õ b  | À|    

  
  ForsÃ¸k« r  | a  | bö	ób  |ë	
-----û+ÜÚØÖÔÒĞ----
    5     |ûù÷õó b  | r  | a  

  
  ForsÃ¸kæ|àaŞ	Û-----û+ÌÊÈÆÄÂÀ
----
    0     | b  | r  | a  |ìëéç	   
    1ÙÕÓÑÏï2ËËÉ| a  |  ûù  
    3   æäâ
| b  | r  Õ
Ó
4  ÍËÉÇÅÃ5     |ûù÷õóD b  | r  | a  








  â€¢ Se pÃ¥ siste tegn i sÃ¸keteksten fÃ¸rstÑHvis det ikke passÅ-r, flytt sÃ¸keteksten sÃ¥ langt vi kan


    û | r  | a  | bö	óbºâ-----+ûù÷õó----+û ----
      0  | b  | r  | a  |  ûù÷õ  Ù1ÇÅÃÁ¿Ë2Ş  |  û  | b  | r  | aç	   
      3Ù	×ÕÓÑî"

  â€¢ Hvis det passer, se pÃ¥ neéatsiste osv.







  â€¢ Hvis tegnet ikke fins i sÃ¸keteksten, kan vi flytte m steg 
    frem:

 ò | m  | e  | tö	“  | r  | i  | tû  | sç	eê	n  
  -----+ûù÷õóñïíëéçåã----Ø"   0  | s  | t  | e  | i  | n  |  ûù÷õóñïí  
    1ÃÁ¿½»Á
  | n  |  ûù÷  
    2åãáßİÛÙ×Õ| s  | t  | e  | iÂ
  

  â€¢ Hvis tegneİ. fins til venstre i sÃ¸keordet, kan vi flytte ëI 
    sÃ¥ det passer med teksten 

  â€¢ Vi har vi en tabell for hvor mye©Z kan flytte

  â€¢ I praksis en tabell for hele alfabetet, hvor de fleste tegn 
    gir etª pÃ¥ m. (Regel om Â«upassendÏBegnÂ»)

  â€¢ Tabellen lager vi ved Ã¥ pre-prosessere sÃ¸ketekstenÄ	egn som fins iâ, gir kortere flytt


 ›L â€“ En Â«sÂ» i siste posisjon gir flytt pÃ¥ m-1, fordi ordet 
      starterÜº'

  â€¢ \Omega\left(n/m\right) for sÃ¸kÃ_. Mye bedre!







  â€¢ Hvis tegnet ikke fins i sÃ¸keteksten, kan vi flytte m steg 
    frem,²  â€“ hvis mismatch var pÃ¥9 siste tegn i sÃ¸keteksten

    â€“ med mismatch pÃ¥ nestÈkan vi flytte m-1 stegÈ
vÏnest¤4ste, flytter vi m-2 steg osv.

  
     | m  | e  | tö	o  | r  | iíë  | sãÜ	®nË-----+ûø+----ûù÷õóñïíëéç
    0  | m  | e  | nö	   | ûù÷õóñØ |   û 
    1 îìê| m  | e  | nö	  ÕÓÑÏÍË"

  â€¢ Vi trenger altsÃ¥ en todimÆ;nsjonal tabell:


    â€“ En indeks er det upassende tegnetÕ
	Den andreÕen er posisjonen i sÃ¸keteksten§
Veerdien i cellen er hvor langt vi kan flytte fremover







  For hver posisjon p i sÃ¸keteksten

   ×
t tegn x i alfab0etet

        let mot start i sÃ¸keteksten fra pÔ
hvis vi finner x etter i steg,³
sett Tab[p][x] = i
Ë@vis vi ikke finner x, Tab[p][x]=p+1







  
     | r  | e  | nûô
ò	å-----+ûù÷õóğ-+---û
    0  | e  | nö	   | ûù÷  ß1ÑÏßËÉÇÏ2Á¿Î| n  | e  |  ûù 
     åãáßãÛ5

  â€¢ 0,1: NÃ¥r siste posisjon treffer Â«nÂ», kan v?i bare flytte ett 
    steg

  â€¢ 2: Feil i fÃ¸rste posisjon

Ó'â€“ Regel om Â«upassende tegnÂ» lar oss˜hakAk

  â€¢ Regel om Â«passende endelseÂ» lar oss flytte to hakk herÀÂ«neÂ» É	t, og Â«eïoverlapper med seg selv,€¢ Vi slÃ¥r opp bÃ¥de Â«upassende tegnÂ» og í	IendelseÂ», og 
    bruker regelen som gir det lengste hoppet. 







  âˆK¢ Tabellen for Â«passende endelseÂ»


    â€“ index er hvor mange tegn som ÆtÕ
verdien i c¨Õ
langt vi k—}n flytte

  â€¢ Lages ved Ã¥ prÃ¸ve ut om sÃ¸keteksten overlapper med seg selv


    â€“ ofte gjÃ¸r den ikke det, og vi fÃ¥r ¾4nge hopp!






  â€¢ Hvis vi sÃ¸ker etter Â«aaaÂ» iö8aaaâ€¦Â», har vi dessverre O\left(n\cdot m\right)
     
ùâ€“¨deordet passer overalt, de samme a-ene sjekkes flere 
      ganger

  â€¢ Galil fant en mÃ¥te Ã¥ unngù	Ã¸dvendig¨nlignÔBnger:

    â€“ NÃ¥r vi flytter sÃ¸keordet kortere enn den delen avÜÂ!  vi allerede har sjekket, trengeªikke¯0jekke det 
      overlappende omrÃ¥det omigjen.
Ú?â€“ Korte flytt skjer fordi sÃ¸keordet delvis matcher seg selv.—Hçs det ikke hadde passet,ò+vi flyttet lenger. 

  
    Teksten     | .ûù  | O  | l  | aö
¢	. |  . |Ç    Mismatch O/a  |  û	  | l  | îùêõÕ
Ó
    Nytt forsÃ¸k¿½»¹·
ÆÑ
 | a  | l öL|    |
  

  â€¢ Programmet trenger ikke sjekke den oransje regionen omigjen½Dermed: O\left(n\right) og îROmega\left(n/m\right) for 
    tekstsÃ¸k







  â€¢ Boyer og Moore sin artikkel:Û'  http://www.cs.utexas.edu/~moore/publiæ7ations/fstrpos.pdf

  â€¢ Wikipedia:


    https://en.wä-.org/wiki/Boyer_moore_string_search_algorithm«Animasjon (}Fyll ut, og velg Boyer-Moore)     Trenger java


    http://www.cs.pitt.edu/~kirk/cs1501/animations/String.html

  â€¢ Demonsè~asjon pÃ¥ Moore sin nettside:

    
http://www.cs.utexas.edu/users/moore/best-ideas/string-searching/fstrpos-example.html

Sekƒ8jon 2 Mer om datakompresjon




  â€¢ Leser gjennom filaæInput kopieres til outputÊHvis en lang nok sekvens komm“Dr omigjen:


    â€“ dropp den, skriv heller en referanse til outputÇ
)format: repeter X tegn, som vi har sett YèÇDdligere

  â€¢ Hjelper hvis sekvensen er lenger enn en slik referansÂ	%SÃ¸ker bakover i et sirkulÃ¦rt buffer›Outpìot kan komprimeres videre med Huffman-koding (Deflate
    -algoritmen, som brukes i zip.)







  â€¢ MÃ¥ vÃ¦re–aktèé~€“ ellers kan vi ikke referere til korte strenger

    â€“ f.eks. 2â€“3 byte

  â€¢ Ã… Â«seÂ» langt bakover i datastrÃ¸mmen, g‘2r stÃ¸rre sjanse for Ã¥ 
    finne repetisjoner.

æâ€“ men ogsÃ¥ lenger kjÃ¸retid
Ä â€“ pÃ¥virker formatet pÃ¥ refer•4ne vÃ¥re


      âˆ— 1 byte kan gÃ¥ 255 tegn bakoverÕ2Ş65â€¯536äÄ3Ío16â€¯777â€¯215 tegn bakover

  â€¢ I blant kan vi ikke komprimere


    â€“ MÃ¥ derfor ogsÃ¥ ha en mÃ¥te Ã¥ si:Ó
HerÁammer X bytes ukomprimerte data

    â€“ Slik informasjon tar ogsÃ¥ plass!







  â€¢ Vurdering:í¿kal dette vÃ¦re e·R del av en stÃ¸rre ukomprimert blokk?

    â€“ Evt. bakover-ref + header for korte¾

  â€¢ Det vi °	œ$r mÃ¥ altsÃ¥ vÃ¦re lenger enn samletîde 
    for:

õâ€“ en bakover-referanse
Ù#â€“ header for en ukomprimert blokk¼:  â€¢ Vi komprimerer ikke svÃ¦rt korte strenger, det hjelpØ	!







º!Eksempeltekst:


    Problemer, põ. Alßid problemer!
Dette er dagenså. Pát er
Ã¥ komprimereÊatisk tekst.

  â€¢ Eksempelê med avstander:


 Ü Problemer,^{10} pğ^{20}. Alltid p^{30}Ù)!
^{40}Dette er d^{50}agens prob^{60}lem.«^{70}emet er
Ã¥ ^{80}komØaimere^{90} problemat^{100}isk tekst.^{110}

  â€¢ 110 tegn, inkludert linjeskift og blanke.





ÉEksempel² med av«ander:


    Problemer,^{10} pğ^{20}. Alltid p^{30}Ù)!
^{40}Dette er d^{50}agens prob^{60}lem.«^{70}emet er
Ã?¥ ^{80}komprimere^{90} problemat^{100}isk tekst.^{110}

  â€¢ KÉt:


    [12]PÈ$er, p[-11,8][8]. Alltid[-18,10][17]!<
Dette er dagens[-27,7][2]. [-65,8][17]t er
Ã¥ komprimere[-3ã2]atisk tekst.

  â€¢ FÃ¸rÕ
ing, 110 tegn. âM“9d 1 byte per tallkode, 84 tegn.


    Vi sparte 110-84=26à, eller 23%




Óâ€¢ For hver¾posisjon i input, mÃ¥ vi sùJ¸ke etter lengste match 
    i bufferet.

  â€¢ Fil med n tegn, sirkulÃ¦rtÔçstÃ¸rrelse mÌ	Teste alle posisjon‘hr, i verste fall O\left(nm^{2}\right)

  â€¢ I praksis gÃ¥r det bedre, sÃ¦rlig hvis data varierer en del½Kan bruke BoyN-Moore tekstsÃ¸k for bedre kjÃ¸retid.







  â€¢ Lempel og Ziv sin artikkel:Ü*  
http://www.cs.duke.edu/courses/spring03ï[ps296.5/papers/ziv_lempel_1977_universal_algorithm.pdf

  â€¢ Wikipedia:


    https://en.wä.org/wiki/L«\%E2\%80\%93Ziv
ÿ