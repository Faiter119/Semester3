TekstsÃ¸k, Datakompresjon

Helge Hafting

IIE

Seksjon 1 TekstsÃ¸k




  â€¢ FritekstsÃ¸k i dokumenter, nettsider og lignende

  â€¢ FritekstsÃ¸k i databaser

  â€¢ SÃ¸kemotorer

  â€¢ SÃ¸ke etter repeterte strenger for datakompresjon

  â€¢ DNA-matching







  Tekst: rabarbra     (lengde n)

  SÃ¸keord: bra     (lengde m)

  Skyv sÃ¸keordet langs teksten, se om det passer


    â€¢ tegn som passer, vises med fet skrift

    â€¢ fÃ¸rste feil med kursiv

    â€¢ dobbeltlÃ¸kke for n-m posisjoner, og m tegn i sÃ¸keordet. 

  


  Hele greia, O\left(n\cdot m\right),\Omega\left(n\right)

  
  ForsÃ¸k  | r  | a  | b  | a  | r  | b  | r  | a  
----------+ |  |  |  |  |  |  | ----
    0     | b  | r  | a  |    |    |    |    |    

  
  ForsÃ¸k  | r  | a  | b  | a  | r  | b  | r  | a  
----------+k  |k  |k  |k  |k  |k  |k  |----
    1     |    | b  | r  | a  |    |    |    |    

  
  ForsÃ¸k  | r  | a  | b  | a  | r  | b  | r  | a  
----------+  |  |  |  |  |  |  |----
    2     |    |    | b  | r  | a  |	  2 	  2   

  
  ForsÃ¸k	  2     |ûùb  | 	  2r  | b  | r  | a  
----------+	  2	  2----+----+----+----+----+----
    3     |    |    |    | b  | r  | a  |---+   

  
  ForsÃ¸k---+-ûù÷õb  | ---r  | b  | r  | a  
----------+r  r  r  r  r  r  r  ----
    4     |    |    |    |    | b  | r  | a  |    

  
  ForsÃ¸k  | r  | a  | b  | a  | r  | b  | r  | a  
----------+ r  r  r  r  r  r  r ----
    5     |    |    |    |    |    | b  | r  | a  

  
  ForsÃ¸k  | r  | a  | b  | a  | r  | b  | r  | a  
----------+ b  b  b  b  b  b  b ----
    0     | b  | r  | a  |    |    |    |    |    
    1     | 0     | b  | r  | a  0   0   0    
    2     |    |    | b  | r  | a  |    |    |    
    3   | a  | a| a| b  | r  | a  |  | a  |  4  | a| a| a| a| a  |  ûù| a  |  ûù5     |    |    |    |    |    | b  | r  | a  








  â€¢ Se pÃ¥ siste tegn i sÃ¸keteksten fÃ¸rst

  â€¢ Hvis det ikke passer, flytt sÃ¸keteksten sÃ¥ langt vi kan


    
     | r  | a  | b  | a  | r  | b-r, flytt s
    -----+----+----+----+----+----+----+----+----
      0  | b  | r  | a  |    |    |    |    |    
      1----+-------+û ----
     ------
      2  |    |    |    | b  | r  | a  |  û   
      3  |  û  |  |  |  |  û  | b  |
    

  â€¢ Hvis det passer, se pÃ¥ nestsiste osv.







  â€¢ Hvis tegnet ikke fins i sÃ¸keteksten, kan vi flytte m steg 
    frem:

  
     | m  | e  | t  | e  | o  | r  | i  | t  | t  | s  | r  e  | i  | n  
  -----+----+----+----+----+----+----+----+----+----+----+----+----+----+----
    0  | s  | t  | e  | i  | n  |    |    |    |    |    |    |    |    |    
    1"   0 "   "   "   "   | s  | t  | e  | i  | n  |    |    |    |    
    2
  | n
  |
  |
  |
  |
  |
  |
  |
  || s  | t  | e  | i  | n  
  

  â€¢ Hvis tegnet fins til venstre i sÃ¸keordet, kan vi flytte ordet 
    sÃ¥ det passer med teksten 

  â€¢ Vi har vi en tabell for hvor mye vi kan flytte

  â€¢ I praksis en tabell for hele alfabetet, hvor de fleste tegn 
    gir et flytt pÃ¥ m. (Regel om Â«upassende tegnÂ»)

  â€¢ Tabellen lager vi ved Ã¥ pre-prosessere sÃ¸keteksten

  â€¢ Tegn som fins i sÃ¸keteksten, gir kortere flytt


    â€“ En Â«sÂ» i siste posisjon gir flytt pÃ¥ m-1, fordi ordet 
      starter pÃ¥ Â«sÂ»

  â€¢ \Omega\left(n/m\right) for sÃ¸ket. Mye bedre!







  â€¢ Hvis tegnet ikke fins i sÃ¸keteksten, kan vi flytte m steg 
    frem,


    â€“ hvis mismatch var pÃ¥ siste tegn i sÃ¸keteksten

    â€“ med mismatch pÃ¥ nestsiste tegn kan vi flytte m-1 steg

    â€“ ved mismatch pÃ¥ nestnestsiste, flytter vi m-2 steg osv.

  
     | m  | e  | t  | e  | o  | r  | i  | t  | t  | s  | t  | e  | 4sten  
  -----+----+----+----+----+----+----+----+----+----+----+----+----+----+----
    0  | m  | e  | n  | e  |    |    |    |    |    |    |    |    |    |    
    1  |   |  | | m  | e  | n  | e  |    |   |  |  |  |  |   û

  â€¢ Vi trenger altsÃ¥ en todimensjonal tabell:


    â€“ En indeks er det upassende tegnet

    â€“ Den andre indeksen er posisjonen i sÃ¸keteksten

    â€“ Verdien i cellen er hvor langt vi kan flytte fremover







  For hver posisjon p i sÃ¸keteksten

     For hvert tegn x i alfabetet

        let mot start i sÃ¸keteksten fra p

        hvis vi finner x etter i steg,

        sett Tab[p][x] = i

        hvis vi ikke finner x, Tab[p][x]=p+1







  
     | r  | e  | n  | n  | e  | n  | e  |   
  -----+----+----+----+----+----+----+----+---
    0  | e  | n  | e  |    |    |    |    |   
    1-+---+---û
| e  | -+----+--+-
    2-+---+- | e  | n  | e  |    |    |   
     | n | n| n| n | e  | | n  | e  |  

  â€¢ 0,1: NÃ¥r siste posisjon treffer Â«nÂ», kan vi bare flytte ett 
    steg

  â€¢ 2: Feil i fÃ¸rste posisjon


    â€“ Regel om Â«upassende tegnÂ» lar oss bare flytte ett hakk

  â€¢ Regel om Â«passende endelseÂ» lar oss flytte to hakk her

  â€¢ Â«neÂ» passet, og Â«eneÂ» overlapper med seg selv

  â€¢ Vi slÃ¥r opp bÃ¥de Â«upassende tegnÂ» og passende endelseÂ», og 
    bruker regelen som gir det lengste hoppet. 







  â€¢ Tabellen for Â«passende endelseÂ»


    â€“ index er hvor mange tegn som passet

    â€“ verdien i cellen er hvor langt vi kan flytte

  â€¢ Lages ved Ã¥ prÃ¸ve ut om sÃ¸keteksten overlapper med seg selv


    â€“ ofte gjÃ¸r den ikke det, og vi fÃ¥r lange hopp!






  â€¢ Hvis vi sÃ¸ker etter Â«aaaÂ» i Â«aaaaaaâ€¦Â», har vi dessverre O\left(n\cdot m\right)
     

    â€“ sÃ¸keordet passer overalt, de samme a-ene sjekkes flere 
      ganger

  â€¢ Galil fant en mÃ¥te Ã¥ unngÃ¥ unÃ¸dvendige sammenligninger:

    â€“ NÃ¥r vi flytter sÃ¸keordet kortere enn den delen av sÃ¸keordet 
      vi allerede har sjekket, trenger vi ikke sjekke det 
      overlappende omrÃ¥det omigjen.

    â€“ Korte flytt skjer fordi sÃ¸keordet delvis matcher seg selv. 
      Hvis det ikke hadde passet, hadde vi flyttet lenger. 

  
    Teksten     | .  | .  | .  | O  | l  | a  | l  | as det i. |  . |
    Mismatch O/a  |    |    | l  | a  | l  | a  | l  |     Mism    Mi
    Nytt forsÃ¸k                Misma  | l  | a  | l  | a |    |
  

  â€¢ Programmet trenger ikke sjekke den oransje regionen omigjen

  â€¢ Dermed: O\left(n\right) og \Omega\left(n/m\right) for 
    tekstsÃ¸k







  â€¢ Boyer og Moore sin artikkel:


    http://www.cs.utexas.edu/~moore/publications/fstrpos.pdf

  â€¢ Wikipedia:


    https://en.wikipedia.org/wiki/Boyer_moore_string_search_algorithm

  â€¢ Animasjon (Fyll ut, og velg Boyer-Moore)     Trenger java


    http://www.cs.pitt.edu/~kirk/cs1501/animations/String.html

  â€¢ Demonstrasjon pÃ¥ Moore sin nettside:

    
http://www.cs.utexas.edu/users/moore/best-ideas/string-searching/fstrpos-example.html

Seksjon 2 Mer om datakompresjon




  â€¢ Leser gjennom fila

  â€¢ Input kopieres til output

  â€¢ Hvis en lang nok sekvens kommer omigjen:


    â€“ dropp den, skriv heller en referanse til output

    â€“ format: repeter X tegn, som vi har sett Y tegn tidligere

  â€¢ Hjelper hvis sekvensen er lenger enn en slik referanse

  â€¢ SÃ¸ker bakover i et sirkulÃ¦rt buffer

  â€¢ Output kan komprimeres videre med Huffman-koding (Deflate
    -algoritmen, som brukes i zip.)







  â€¢ MÃ¥ vÃ¦re kompakt


    â€“ ellers kan vi ikke referere til korte strenger

    â€“ f.eks. 2â€“3 byte

  â€¢ Ã… Â«seÂ» langt bakover i datastrÃ¸mmen, gir stÃ¸rre sjanse for Ã¥ 
    finne repetisjoner.


    â€“ men ogsÃ¥ lenger kjÃ¸retid

    â€“ pÃ¥virker formatet pÃ¥ referansene vÃ¥re


      âˆ— 1 byte kan gÃ¥ 255 tegn bakover

      âˆ— 2 byte kan gÃ¥ 65â€¯536 tegn bakover

      âˆ— 3 byte kan gÃ¥ 16â€¯777â€¯215 tegn bakover

  â€¢ I blant kan vi ikke komprimere


    â€“ MÃ¥ derfor ogsÃ¥ ha en mÃ¥te Ã¥ si:

    â€“ Her kommer X bytes ukomprimerte data

    â€“ Slik informasjon tar ogsÃ¥ plass!







  â€¢ Vurdering:


    â€“ Skal dette vÃ¦re en del av en stÃ¸rre ukomprimert blokk?

    â€“ Evt. bakover-ref + header for kortere ukomprimert blokk

  â€¢ Det vi komprimerer mÃ¥ altsÃ¥ vÃ¦re lenger enn samlet lengde 
    for:


    â€“ en bakover-referanse

    â€“ header for en ukomprimert blokk

  â€¢ Vi komprimerer ikke svÃ¦rt korte strenger, det hjelper ikke!







  â€¢ Eksempeltekst:


    Problemer, problemer. Alltid problemer!
Dette er dagens problem. Problemet er
Ã¥ komprimere problematisk tekst.

  â€¢ Eksempeltekst med avstander:


    Problemer,^{10} problemer^{20}. Alltid p^{30}roblemer!
^{40}Dette er d^{50}agens prob^{60}lem. Probl^{70}emet er
Ã¥ ^{80}komprimere^{90} problemat^{100}isk tekst.^{110}

  â€¢ 110 tegn, inkludert linjeskift og blanke.







  â€¢ Eksempeltekst med avstander:


    Problemer,^{10} problemer^{20}. Alltid p^{30}roblemer!
^{40}Dette er d^{50}agens prob^{60}lem. Probl^{70}emet er
Ã¥ ^{80}komprimere^{90} problemat^{100}isk tekst.^{110}

  â€¢ Komprimert:


    [12]Problemer, p[-11,8][8]. Alltid[-18,10][17]!
Dette er dagens[-27,7][2]. [-65,8][17]t er
Ã¥ komprimere[-35,8][12]atisk tekst.

  â€¢ FÃ¸r komprimering, 110 tegn. 

  â€¢ Med 1 byte per tallkode, 84 tegn.


    Vi sparte 110-84=26 tegn, eller 23%







  â€¢ For hver tegnposisjon i input, mÃ¥ vi sÃ¸ke etter lengste match 
    i bufferet.

  â€¢ Fil med n tegn, sirkulÃ¦rt buffer med stÃ¸rrelse m.

  â€¢ Teste alle posisjoner, i verste fall O\left(nm^{2}\right)

  â€¢ I praksis gÃ¥r det bedre, sÃ¦rlig hvis data varierer en del

  â€¢ Kan bruke Boyer-Moore tekstsÃ¸k for bedre kjÃ¸retid.







  â€¢ Lempel og Ziv sin artikkel:


    
http://www.cs.duke.edu/courses/spring03/cps296.5/papers/ziv_lempel_1977_universal_algorithm.pdf

  â€¢ Wikipedia:


    https://en.wikipedia.org/wiki/Lempel\%E2\%80\%93Ziv

